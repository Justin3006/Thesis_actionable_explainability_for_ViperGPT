[INST]
class ImagePatch:
    """A Python class containing a crop of an image centered around a particular object, as well as relevant information.
    Attributes
    ----------
    cropped_image : array_like
        An array-like of the cropped image taken from the original image.
    left, lower, right, upper : int
        An int describing the position of the (left/lower/right/upper) border of the crop's bounding box in the original image.

    Methods
    -------
    find(object_name: str)->List[ImagePatch]
        Returns a list of new ImagePatch objects containing crops of the image centered around any objects found in the
        image matching the object_name.
    exists(object_name: str)->bool
        Returns True if the object specified by object_name is found in the image, and False otherwise.
    verify_property(property: str)->bool
        Returns True if the property is met, and False otherwise.
    best_text_match(option_list: List[str], prefix: str)->str
        Returns the string that best matches the image.
    simple_query(question: str=None)->str
        Returns the answer to a basic question asked about the image. If no question is provided, returns the answer to "What is this?".
    llm_query(question: str, long_answer: bool)->str
        References a large language model (e.g., GPT) to produce a response to the given question. Default is short-form answers, can be made long-form responses with the long_answer flag.
    compute_depth()->float
        Returns the median depth of the image crop.
    crop(left: int, lower: int, right: int, upper: int)->ImagePatch
        Returns a new ImagePatch object containing a crop of the image at the given coordinates.
    """

    def __init__(self, image, left: int = None, lower: int = None, right: int = None, upper: int = None):
        """Initializes an ImagePatch object by cropping the image at the given coordinates and stores the coordinates as
        attributes. If no coordinates are provided, the image is left unmodified, and the coordinates are set to the
        dimensions of the image.
        Parameters
        -------
        image : array_like
            An array-like of the original image.
        left, lower, right, upper : int
            An int describing the position of the (left/lower/right/upper) border of the crop's bounding box in the original image.
        """
        if left is None and right is None and upper is None and lower is None:
            self.cropped_image = image
            self.left = 0
            self.lower = 0
            self.right = image.shape[2]  # width
            self.upper = image.shape[1]  # height
        else:
            self.cropped_image = image[:, lower:upper, left:right]
            self.left = left
            self.upper = upper
            self.right = right
            self.lower = lower

        self.width = self.cropped_image.shape[2]
        self.height = self.cropped_image.shape[1]

        self.horizontal_center = (self.left + self.right) / 2
        self.vertical_center = (self.lower + self.upper) / 2

    def find(self, object_name: str) -> List[ImagePatch]:
        """Returns a list of ImagePatch objects matching object_name contained in the crop if any are found.
        Otherwise, returns an empty list.
        Parameters
        ----------
        object_name : str
            the name of the object to be found

        Returns
        -------
        List[ImagePatch]
            a list of ImagePatch objects matching object_name contained in the crop
        """
        return find_in_image(self.cropped_image, object_name)

    def exists(self, object_name: str) -> bool:
        """Returns True if the object specified by object_name is found in the image, and False otherwise.
        Parameters
        -------
        object_name : str
            A string describing the name of the object to be found in the image.
        """
        return len(self.find(object_name)) > 0

    def verify_property(self, object_name: str, visual_property: str) -> bool:
        """Returns True if the object possesses the visual property, and False otherwise.
        Differs from 'exists' in that it presupposes the existence of the object specified by object_name, instead checking whether the object possesses the property.
        Parameters
        -------
        object_name : str
            A string describing the name of the object to be found in the image.
        visual_property : str
            A string describing the simple visual property (e.g., color, shape, material) to be checked.
        """
        return verify_property(self.cropped_image, object_name, property)

    def best_text_match(self, option_list: List[str], prefix: str=None) -> str:
        """Returns the string that best matches the image.
        Parameters
        -------
        option_list : str
            A list with the names of the different options
        prefix : str
            A string with the prefixes to append to the options
        """
        return best_text_match(self.cropped_image, option_list, prefix)

    def simple_query(self, question: str = None) -> str:
        """Returns the answer to a basic question asked about the image. If no question is provided, returns the answer
        to "What is this?". The questions are about basic perception, and are not meant to be used for complex reasoning
        or external knowledge.
        Parameters
        -------
        question : str
            A string describing the question to be asked.
        """
        return simple_query(self.cropped_image, question)

    def compute_depth(self):
        """Returns the median depth of the image crop
        Parameters
        ----------
        Returns
        -------
        float
            the median depth of the image crop
        """
        depth_map = compute_depth(self.cropped_image)
        return depth_map.median()

    def crop(self, left: int, lower: int, right: int, upper: int) -> ImagePatch:
        """Returns a new ImagePatch cropped from the current ImagePatch.
        Parameters
        -------
        left, lower, right, upper : int
            The (left/lower/right/upper)most pixel of the cropped image.
        -------
        """
        return ImagePatch(self.cropped_image, left, lower, right, upper)

    def overlaps_with(self, left, lower, right, upper):
        """Returns True if a crop with the given coordinates overlaps with this one,
        else False.
        Parameters
        ----------
        left, lower, right, upper : int
            the (left/lower/right/upper) border of the crop to be checked

        Returns
        -------
        bool
            True if a crop with the given coordinates overlaps with this one, else False
        """
        return self.left <= right and self.right >= left and self.lower <= upper and self.upper >= lower

    def llm_query(self, question: str, long_answer: bool = True) -> str:
        '''Answers a text question using GPT-3. The input question is always a formatted string with a variable in it.

        Parameters
        ----------
        question: str
            the text question to ask. Must not contain any reference to 'the image' or 'the photo', etc.
        long_answer: bool
            whether to return a short answer or a long answer. Short answers are one or at most two words, very concise.
            Long answers are longer, and may be paragraphs and explanations. Defalt is True (so long answer).
        '''
        return llm_query(question, long_answer)

def best_image_match(list_patches: List[ImagePatch], content: List[str], return_index=False) -> Union[ImagePatch, int]:
    """Returns the patch most likely to contain the content.
    Parameters
    ----------
    list_patches : List[ImagePatch]
    content : List[str]
        the object of interest
    return_index : bool
        if True, returns the index of the patch most likely to contain the object

    Returns
    -------
    int
        Patch most likely to contain the object
    """
    return best_image_match(list_patches, content, return_index)

def distance(patch_a: ImagePatch, patch_b: ImagePatch) -> float:
    """
    Returns the distance between the edges of two ImagePatches. If the patches overlap, it returns a negative distance
    corresponding to the negative intersection over union.

    Parameters
    ----------
    patch_a : ImagePatch
    patch_b : ImagePatch
    """
    return distance(patch_a, patch_b)

def bool_to_yesno(bool_answer: bool) -> str:
    """
    This function takes a boolean as input and returns the respective string.
    """
    return "yes" if bool_answer else "no"

def coerce_to_numeric(string: str) -> float:
    """
    This function takes a string as input and returns a float after removing any non-numeric characters.
    If the input string contains a range (e.g. "10-15"), it returns the first value in the range.
    """
    return coerce_to_numeric(string)

# Examples of using ImagePatch
# Is there a backpack to the right of the man?
def execute_command(image)->str:
    image_patch = ImagePatch(image)
    man_patches = image_patch.find("man")
    # query assumes one man patch
    if len(man_patches) == 0:
        # If no man is found, query the image directly
        return image_patch.simple_query("Is there a backpack to the right of the man?")
    man_patch = man_patches[0]
    backpack_patches = image_patch.find("backpack")
    # query assumes one backpack patch
    if len(backpack_patches) == 0:
        return "no"
    for backpack_patch in backpack_patches:
        if backpack_patch.horizontal_center > man_patch.horizontal_center:
            return "yes"
    return "no"

# In which part is the bread, the bottom or the top?
def execute_command(image)->str:
    image_patch = ImagePatch(image)
    bread_patches = image_patch.find("bread")
    # query assumes only one bread patch
    if len(bread_patches) == 0:
        # If no bread is found, query the image directly
        return image_patch.simple_query("In which part is the bread, the bottom or the top?")
    if bread_patches[0].vertical_center < image_patch.vertical_center:
        return "bottom"
    else:
        return "top"

# What type of weather do you see in the photograph?
def execute_command(image)->str:
    image_patch = ImagePatch(image)
    return image_patch.simple_query("What type of weather do you see in the photograph?")

# Who is the man staring at?
def execute_command(image)->str:
    # asks for the predicate of a relational verb (staring at), so ask directly
    image_patch = ImagePatch(image)
    return image_patch.simple_query("Who is the man staring at?")

# What toy is wearing a shirt?
def execute_command(image)->str:
    # not a relational verb so go step by step
    image_patch = ImagePatch(image)
    toy_patches = image_patch.find("toy")
    # query assumes only one toy patch
    if len(toy_patches) == 0:
        # If no toy is found, query the image directly
        return image_patch.simple_query("What toy is wearing a shirt?")
    for toy_patch in toy_patches:
        is_wearing_shirt = (toy_patch.simple_query("Is the toy wearing a shirt?") == "yes")
        if is_wearing_shirt:
            return toy_patch.simple_query("What toy is wearing a shirt?") # crop would include the shirt so keep it in the query
    # If no toy is wearing a shirt, pick the first toy
    return toy_patches[0].simple_query("What toy is wearing a shirt?")

# What is behind the pole?
def execute_command(image)->str:
    image_patch = ImagePatch(image)
    # contains a relation (around, next to, on, near, on top of, in front of, behind, etc), so ask directly
    return image_patch.simple_query("What is behind the pole?")

# Are there bagels or lemons?
def execute_command(image)->str:
    image_patch = ImagePatch(image)
    is_bagel = image_patch.exists("bagel")
    is_lemon = image_patch.exists("lemon")
    return bool_to_yesno(is_bagel or is_lemon)

# Is that blanket to the right of a pillow?
def execute_command(image)->str:
    image_patch = ImagePatch(image)
    blanket_patches = image_patch.find("blanket")
    # query assumes only one blanket patch
    if len(blanket_patches) == 0:
        # If no blanket is found, query the image directly
        return image_patch.simple_query("Is that blanket to the right of a pillow?")
    for blanket_patch in blanket_patches:
        pillow_patches = image_patch.find("pillow")
        for pillow_patch in pillow_patches:
            if pillow_patch.horizontal_center > blanket_patch.horizontal_center:
                return "yes"
    return "no"

# What kind of flowers are these?
def execute_command(image)->str:
    # The question is direct perception, so we can just ask the image
    # There is no additional information needed.
    image = ImagePatch(image)
    direct_guess = image.simple_query("What kind of flowers are these?")
    return direct_guess

# What do these people on the bikes normally write and give out?
def execute_command(image)->str:
    # The question is not direct perception, so we need to ask the image for more information
    # What information do we need? We need to know who these people on the bikes are.
    image = ImagePatch(image)
    guesses = []
    people_on_bikes = image.simple_query("Who are these people on the bikes?")
    external_knowledge_query = "What do {} normally write and give out?".format(people_on_bikes)
    step_by_step_guess = llm_query(external_knowledge_query)
    guesses.append("these people on the bikes are {}".format(people_on_bikes) + ", so " + step_by_step_guess)
    direct_guess = image.simple_query("What do these people on the bikes normally write and give out?")
    guesses.append(direct_guess)
    return process_guesses("What do these people on the bikes normally write and give out?", guesses)

# What are these children doing?
def execute_command(image)->str:
    # The question is direct perception, so we can just ask the image
    # Salient information: what are these children doing?
    image = ImagePatch(image)
    direct_guess = image.simple_query("What are these children watching?")
    return direct_guess

# Is this the mountains or desert?
def execute_command(image)->str:
    # The question is not direct perception, so we need to ask the image for more information
    # Salient information: is this the mountains? is this the desert?
    # Question contains "or", so the answer must be "mountains" or "desert"
    image = ImagePatch(image)
    guesses = []
    mountains = image.simple_query("Is this the mountains?")
    desert = image.simple_query("Is this the desert?")
    if mountains == "yes":
        guesses.append("this is the mountains")
    if desert == "yes":
        guesses.append("this is the desert")
    direct_guess = image.simple_query("Is this the mountains or desert?")
    guesses.append(direct_guess)
    return process_guesses("Is this the mountains or desert?", guesses)

# Who is famous for allegedly doing this in a lightning storm?
def execute_command(image)->str:
    # The question is not direct perception, so we need to ask the image for more information
    # Salient information: what is being done?
    image = ImagePatch(image)
    guesses = []
    action = image.simple_query("What is being done?")
    external_knowledge_query = "Who is famous for allegedly {} in a lightning storm?".format(action)
    step_by_step_guess = llm_query(external_knowledge_query)
    guesses.append("what is being done is {}".format(action) + ", so " + step_by_step_guess)
    direct_guess = image.simple_query("Who is famous for allegedly doing this in a lightning storm?")
    guesses.append(direct_guess)
    return process_guesses("Who is famous for allegedly doing this in a lightning storm?", guesses)

# Should you bake or roast this item?
def execute_command(image)->str:
    # The question is not direct perception, so we need to ask the image for more information
    # Salient information: what is this item?
    # Question contains "or", so the answer must be "bake" or "roast"
    image = ImagePatch(image)
    guesses = []
    item = image.simple_query("What is this item?")
    external_knowledge_query = "Should you bake or roast {}?".format(item)
    step_by_step_guess = llm_query(external_knowledge_query)
    guesses.append("what is this item is {}".format(item) + ", so " + step_by_step_guess)
    direct_guess = image.simple_query("Should you bake or roast this item?")
    guesses.append(direct_guess)
    return process_guesses("Should you bake or roast this item?", guesses)

# Where can I get a laptop like the one found here?
def execute_command(image)->str:
    # The question is not direct perception, so we need to ask the image for more information
    # Salient information: what kind of laptop is this?
    image = ImagePatch(image)
    guesses = []
    laptop_type = image.simple_query("What kind of laptop is this?")
    external_knowledge_query = "Where can I get a {} like the one found here?".format(laptop_type)
    step_by_step_guess = llm_query(external_knowledge_query)
    guesses.append("what kind of laptop is this is {}".format(laptop_type) + ", so " + step_by_step_guess)
    direct_guess = image.simple_query("Where can I get a laptop like the one found here?")
    guesses.append(direct_guess)
    return process_guesses("Where can I get a laptop like the one found here?", guesses)

# return the foo
def execute_command(image) -> List[ImagePatch]:
    image_patch = ImagePatch(image)
    foo_patches = image_patch.find("foo")
    return foo_patches

# Are there both foos and garply bars in the photo?
def execute_command(image) -> str:
    image_patch = ImagePatch(image)
    is_foo = image_patch.exists("foo")
    is_garply_bar = image_patch.exists("garply bar")
    return bool_to_yesno(is_foo and is_garply_bar)

# Do the letters have blue color?
def execute_command(image) -> str:
    image_patch = ImagePatch(image)
    letters_patches = image_patch.find("letters")
    # Question assumes only one letter patch
    return bool_to_yesno(letters_patches[0].verify_property("letters", "blue"))

# Is the foo gold or white?
def execute_command(image) -> str:
    image_patch = ImagePatch(image)
    foo_patches = image_patch.find("foo")
    # Question assumes one foo patch
    return foo_patches[0].best_text_match(["gold", "white"])

# Which kind of baz is not fredding?
def execute_command(image) -> str:
    image_patch = ImagePatch(image)
    baz_patches = image_patch.find("baz")
    for baz_patch in baz_patches:
        if not baz_patch.verify_property("baz", "fredding"):
            return baz_patch.simple_query("What is this baz?")

# What color is the foo?
def execute_command(image) -> str:
    image_patch = ImagePatch(image)
    foo_patches = image_patch.find("foo")
    foo_patch = foo_patches[0]
    return foo_patch.simple_query("What is the color?")

# Is the second bar from the left quuxy?
def execute_command(image) -> str:
    image_patch = ImagePatch(image)
    bar_patches = image_patch.find("bar")
    bar_patches.sort(key=lambda x: x.horizontal_center)
    bar_patch = bar_patches[1]
    return bar_patch.simple_query("Is the bar quuxy?")

# the bar furthest away
def execute_command(image) -> ImagePatch:
    image_patch = ImagePatch(image)
    bar_patches = image_patch.find("bar")
    bar_patches.sort(key=lambda bar: bar.compute_depth())
    return bar_patches[-1]

# black foo on top of the qux
def execute_command(image) -> ImagePatch:
    image_patch = ImagePatch(image)
    qux_patches = image_patch.find("qux")
    qux_patch = qux_patches[0]
    foo_patches = image_patch.find("black foo")
    for foo in foo_patches:
        if foo.vertical_center > qux_patch.vertical_center
            return foo

# What is the city this building is in?
def execute_command(image) -> str:
    image_patch = ImagePatch(image)
    building_patches = image_patch.find("building")
    building_patch = building_patches[0]
    building_name = building_patch.simple_query("What is the name of the building?")
    return building_patch.llm_query(f"What city is {building_name} in?", long_answer=False)

# Who invented this object?
def execute_command(image) -> str:
    image_patch = ImagePatch(image)
    object_patches = image_patch.find("object")
    object_patch = object_patches[0]
    object_name = object_patch.simple_query("What is the name of the object?")
    return object_patch.llm_query(f"Who invented {object_name}?", long_answer=False)

# Explain the history behind this object.
def execute_command(image) -> str:
    image_patch = ImagePatch(image)
    object_patches = image_patch.find("object")
    object_patch = object_patches[0]
    object_name = object_patch.simple_query("What is the name of the object?")
    return object_patch.llm_query(f"What is the history behind {object_name}?", long_answer=True)

def execute_command(image) -> ImagePatch:
    image_patch = ImagePatch(image)
    qux_patches = image_patch.find('qux')
    foo_patches = image_patch.find('foo')
    foo_patch = foo_patches[0]
    qux_patches.sort(key=lambda x: distance(x, foo_patch))
    return qux_patches[0]

Write a function using Python and the ImagePatch class (above) that could be executed to provide an answer to the query. 

Consider the following guidelines:
- Use base Python (comparison, sorting) for basic logical operations, left/right/up/down, math, etc.
- Use only 'INSERT_TYPE_HERE' as a parameter to the function.
- Put your code between [CODE] and [/CODE]
- Do not return the instructions or API back.

Query: INSERT_QUERY_HERE
[/INST]